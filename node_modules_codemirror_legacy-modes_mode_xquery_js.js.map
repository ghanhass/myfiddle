{"version":3,"file":"node_modules_codemirror_legacy-modes_mode_xquery_js.js","mappings":"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","sources":["./node_modules/@codemirror/legacy-modes/mode/xquery.js"],"sourcesContent":["// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return startString(stream, state, ch);\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == quote) {\n        popStateStack(state);\n        if (f) state.tokenize = f;\n        break;\n      } else if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        pushStateStack(state, { type: \"codeblock\"});\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nfunction startString(stream, state, quote, f) {\n  let tokenize = tokenString(quote, f);\n  pushStateStack(state, { type: \"string\", name: quote, tokenize });\n  return chain(stream, state, tokenize);\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return startString(stream, state, ch, tokenAttribute);\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nexport const xQuery = {\n  name: \"xquery\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n"],"names":["keywords","kw","type","style","operator","atom","punctuation","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","startString","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","tokenString","quote","isInXmlAttributeBlock","name","isVariableChar","tokenAttribute","isIn","isInString","stack","newState","push","pop","reinstateTokenize","xQuery","startState","cc","token","languageData","commentTokens","block","open","close"],"sourceRoot":"webpack:///","x_google_ignoreList":[0]}